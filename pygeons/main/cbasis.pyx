# distutils: extra_compile_args = -fopenmp
# distutils: extra_link_args = -fopenmp                                        
''' 
Cython module containing some hard-coded RBF basis functions. These
functions should be faster than the functions generated by *ufuncify*.
'''
# python imports
from __future__ import division
import numpy as np
import rbf.basis
# cython import 
cimport numpy as np
from cython.parallel cimport prange
from libc.math cimport exp, sqrt, fabs
from cython cimport boundscheck,wraparound,cdivision


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef exp_0(double[:,:] x1, 
            double[:,:] c1, 
            double[:] eps):
  ''' 
  parameters
  ----------
  x1 : (N,1) float array
  c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      r = fabs(x1[i,0] - c1[0,j])
      out[i,j] = exp(-r/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef exp_00(double[:,:] x1, double[:,:] x2,
             double[:,:] c1, double[:,:] c2,
             double[:] eps):
  ''' 
  parameters
  ----------
  x1,x2 : (N,1) float array
  c1,c2 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      r = sqrt((x1[i,0] - c1[0,j])**2 +
               (x2[i,0] - c2[0,j])**2)
      out[i,j] = exp(-r/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef se_0(double[:,:] x1, 
           double[:,:] c1, 
           double[:] eps):
  ''' 
  parameters
  ----------
  x1 : (N,1) float array
  c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      r = fabs(x1[i,0] - c1[0,j])
      out[i,j] = exp(-r**2/(2*eps[j]**2))
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef se_00(double[:,:] x1, double[:,:] x2,
            double[:,:] c1, double[:,:] c2,
            double[:] eps):
  ''' 
  parameters
  ----------
  x1,x2 : (N,1) float array
  c1,c2 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      r = sqrt((x1[i,0] - c1[0,j])**2 +
               (x2[i,0] - c2[0,j])**2)
      out[i,j] = exp(-r**2/(2*eps[j]**2))
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef mat32_0(double[:,:] x1, 
              double[:,:] c1, 
              double[:] eps):
  ''' 
  parameters
  ----------
  x1 : (N,1) float array
  c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      r = fabs(x1[i,0] - c1[0,j])
      out[i,j] = (1.0 + sqrt(3.0)*r/eps[j])*exp(-sqrt(3.0)*r/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef mat32_00(double[:,:] x1, double[:,:] x2,
               double[:,:] c1, double[:,:] c2,
               double[:] eps):
  ''' 
  parameters
  ----------
  x1,x2 : (N,1) float array
  c1,c2 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      r = sqrt((x1[i,0] - c1[0,j])**2 +
               (x2[i,0] - c2[0,j])**2)
      out[i,j] = (1.0 + sqrt(3.0)*r/eps[j])*exp(-sqrt(3.0)*r/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef mat52_0(double[:,:] x1, 
              double[:,:] c1, 
              double[:] eps):
  ''' 
  parameters
  ----------
  x1 : (N,1) float array
  c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      r = fabs(x1[i,0] - c1[0,j])
      out[i,j] = (1.0 + sqrt(5.0)*r/eps[j] + 5.0*r**2/(3.0*eps[j]**2))*exp(-sqrt(5.0)*r/eps[j])        

  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef mat52_00(double[:,:] x1, double[:,:] x2,
               double[:,:] c1, double[:,:] c2,
               double[:] eps):
  ''' 
  parameters
  ----------
  x1,x2 : (N,1) float array
  c1,c2 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x1.shape[0]
    int m = c1.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      r = sqrt((x1[i,0] - c1[0,j])**2 +
               (x2[i,0] - c2[0,j])**2)
      out[i,j] = (1.0 + sqrt(5.0)*r/eps[j] + 5.0*r**2/(3.0*eps[j]**2))*exp(-sqrt(5.0)*r/eps[j])        
        
  return np.asarray(out)


def add_diffs_to_caches():
  ''' 
  places the hard-coded cythonized functions in the RBF caches
  ''' 
  rbf.basis.exp.backend = 'numpy'
  rbf.basis.exp.cache[(0,)] = exp_0
  rbf.basis.exp.cache[(0,0)] = exp_00

  rbf.basis.se.backend = 'numpy'
  rbf.basis.se.cache[(0,)] = se_0
  rbf.basis.se.cache[(0,0)] = se_00

  rbf.basis.mat32.backend = 'numpy'
  rbf.basis.mat32.cache[(0,)] = mat32_0
  rbf.basis.mat32.cache[(0,0)] = mat32_00

  rbf.basis.mat52.backend = 'numpy'
  rbf.basis.mat52.cache[(0,)] = mat52_0
  rbf.basis.mat52.cache[(0,0)] = mat52_00
  return

def test_diffs():
  ''' 
  make sure the hard coded functions are all working
  '''
  x1 = np.random.random((10,1))
  x2 = np.random.random((10,2))
  c1 = np.random.random((15,1))
  c2 = np.random.random((15,2))
  eps = np.random.random((15,))
  
  # test exp 1d
  rbf.basis.exp.clear_cache()
  out1 = rbf.basis.exp(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.exp(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'exp_0'

  # test exp 2d
  rbf.basis.exp.clear_cache()
  out1 = rbf.basis.exp(x2,c2,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.exp(x2,c2,eps=eps)
  assert np.all(np.isclose(out1,out2)),'exp_00'

  # test se 1d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.se(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'se_0'

  # test se 2d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x2,c2,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.se(x2,c2,eps=eps)
  assert np.all(np.isclose(out1,out2)),'se_00'

  # test mat32 1d
  rbf.basis.mat32.clear_cache()
  out1 = rbf.basis.mat32(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat32(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat32_0'

  # test mat32 2d
  rbf.basis.mat32.clear_cache()
  out1 = rbf.basis.mat32(x2,c2,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat32(x2,c2,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat32_00' 

  # test mat52 1d
  rbf.basis.mat52.clear_cache()
  out1 = rbf.basis.mat52(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat52(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat52_0'

  # test mat52 2d
  rbf.basis.mat52.clear_cache()
  out1 = rbf.basis.mat52(x2,c2,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat52(x2,c2,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat52_00'
