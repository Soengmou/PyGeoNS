# distutils: extra_compile_args = -fopenmp
# distutils: extra_link_args = -fopenmp                                        
''' 
Cython module containing some hard-coded RBF basis functions. These
functions should be faster than the functions generated by *ufuncify*.
'''
# python imports
from __future__ import division
import numpy as np
import rbf.basis
# cython import 
cimport numpy as np
from cython.parallel cimport prange
from libc.math cimport exp, sqrt, fabs
from cython cimport boundscheck,wraparound,cdivision


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray exp_0(double[:,:] x0, 
                       double[:,:] c0, 
                       double[:] eps):
  ''' 
  parameters
  ----------
  x0 : (N,1) float array
  c0 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = exp(-sqrt((x0[i,0] - c0[0,j])**2)/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray exp_00(double[:,:] x0, double[:,:] x1,
                        double[:,:] c0, double[:,:] c1,
                        double[:] eps):
  ''' 
  parameters
  ----------
  x0,x1 : (N,1) float array
  c0,c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = exp(-sqrt((x0[i,0] - c0[0,j])**2 + (x1[i,0] - c1[0,j])**2)/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray se_0(double[:,:] x0, 
                      double[:,:] c0, 
                      double[:] eps):
  ''' 
  parameters
  ----------
  x0 : (N,1) float array
  c0 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = exp(-(x0[i,0] - c0[0,j])**2/(2*eps[j]**2))        

  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray se_1(double[:,:] x0, 
                      double[:,:] c0, 
                      double[:] eps):
  ''' 
  parameters
  ----------
  x0 : (N,1) float array
  c0 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = -(2*x0[i,0] - 2*c0[0,j])*exp(-(x0[i,0] - c0[0,j])**2/(2*eps[j]**2))/(2*eps[j]**2)    
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray se_00(double[:,:] x0, double[:,:] x1,
                       double[:,:] c0, double[:,:] c1,
                       double[:] eps):
  ''' 
  parameters
  ----------
  x0,x1 : (N,1) float array
  c0,c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = exp(-((x0[i,0] - c0[0,j])**2 + (x1[i,0] - c1[0,j])**2)/(2*eps[j]**2))
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray se_10(double[:,:] x0, double[:,:] x1,
                       double[:,:] c0, double[:,:] c1,
                       double[:] eps):
  ''' 
  parameters
  ----------
  x0,x1 : (N,1) float array
  c0,c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = -(2*x0[i,0] - 2*c0[0,j])*exp(-((x0[i,0] - c0[0,j])**2 + (x1[i,0] - c1[0,j])**2)/(2*eps[j]**2))/(2*eps[j]**2)        

  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray se_01(double[:,:] x0, double[:,:] x1,
                       double[:,:] c0, double[:,:] c1,
                       double[:] eps):
  ''' 
  parameters
  ----------
  x0,x1 : (N,1) float array
  c0,c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      out[i,j] = -(2*x1[i,0] - 2*c1[0,j])*exp(-((x0[i,0] - c0[0,j])**2 + (x1[i,0] - c1[0,j])**2)/(2*eps[j]**2))/(2*eps[j]**2)        

  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray mat32_0(double[:,:] x0, 
                         double[:,:] c0, 
                         double[:] eps):
  ''' 
  parameters
  ----------
  x0 : (N,1) float array
  c0 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      r = fabs(x0[i,0] - c0[0,j])
      out[i,j] = (1.0 + sqrt(3.0)*r/eps[j])*exp(-sqrt(3.0)*r/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray mat32_00(double[:,:] x0, double[:,:] x1,
                          double[:,:] c0, double[:,:] c1,
                          double[:] eps):
  ''' 
  parameters
  ----------
  x0,x1 : (N,1) float array
  c0,c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      r = sqrt((x0[i,0] - c0[0,j])**2 +
               (x1[i,0] - c1[0,j])**2)
      out[i,j] = (1.0 + sqrt(3.0)*r/eps[j])*exp(-sqrt(3.0)*r/eps[j])
        
  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray mat52_0(double[:,:] x0, 
                         double[:,:] c0, 
                         double[:] eps):
  ''' 
  parameters
  ----------
  x0 : (N,1) float array
  c0 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)
    
  for i in prange(n,nogil=True):
    for j in range(m):
      r = fabs(x0[i,0] - c0[0,j])
      out[i,j] = (1.0 + sqrt(5.0)*r/eps[j] + 5.0*r**2/(3.0*eps[j]**2))*exp(-sqrt(5.0)*r/eps[j])        

  return np.asarray(out)


@boundscheck(False)
@wraparound(False)
@cdivision(True)
cpdef np.ndarray mat52_00(double[:,:] x0, double[:,:] x1,
                          double[:,:] c0, double[:,:] c1,
                          double[:] eps):
  ''' 
  parameters
  ----------
  x0,x1 : (N,1) float array
  c0,c1 : (1,M) float array
  eps : (M,) float array
  
  Returns
  -------
  out : (N,M) float array
  
  '''
  cdef:
    int i,j
    int n = x0.shape[0]
    int m = c0.shape[1]
    double r
    double[:,:] out = np.empty((n,m),dtype=np.float64)

  for i in prange(n,nogil=True):
    for j in range(m):
      r = sqrt((x0[i,0] - c0[0,j])**2 +
               (x1[i,0] - c1[0,j])**2)
      out[i,j] = (1.0 + sqrt(5.0)*r/eps[j] + 5.0*r**2/(3.0*eps[j]**2))*exp(-sqrt(5.0)*r/eps[j])        
        
  return np.asarray(out)


def add_diffs_to_caches():
  ''' 
  places the hard-coded cythonized functions in the RBF caches
  ''' 
  rbf.basis.exp.backend = 'numpy'
  rbf.basis.exp.cache[(0,)] = exp_0
  rbf.basis.exp.cache[(0,0)] = exp_00

  rbf.basis.se.backend = 'numpy'
  rbf.basis.se.cache[(0,)] = se_0
  rbf.basis.se.cache[(1,)] = se_1
  rbf.basis.se.cache[(0,0)] = se_00
  rbf.basis.se.cache[(1,0)] = se_10
  rbf.basis.se.cache[(0,1)] = se_01

  rbf.basis.mat32.backend = 'numpy'
  rbf.basis.mat32.cache[(0,)] = mat32_0
  rbf.basis.mat32.cache[(0,0)] = mat32_00

  rbf.basis.mat52.backend = 'numpy'
  rbf.basis.mat52.cache[(0,)] = mat52_0
  rbf.basis.mat52.cache[(0,0)] = mat52_00
  return


def test_diffs():
  ''' 
  make sure the hard coded functions are all working
  '''
  x0 = np.random.random((10,1))
  x1 = np.random.random((10,2))
  c0 = np.random.random((15,1))
  c1 = np.random.random((15,2))
  eps = np.random.random((15,))
  
  # test exp 1d
  rbf.basis.exp.clear_cache()
  out1 = rbf.basis.exp(x0,c0,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.exp(x0,c0,eps=eps)
  assert np.all(np.isclose(out1,out2)),'exp_0'

  # test exp 2d
  rbf.basis.exp.clear_cache()
  out1 = rbf.basis.exp(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.exp(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'exp_00'

  # test se 1d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x0,c0,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.se(x0,c0,eps=eps)
  assert np.all(np.isclose(out1,out2)),'se_0'

  # test se 1d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x0,c0,eps=eps,diff=(1,))
  add_diffs_to_caches()
  out2 = rbf.basis.se(x0,c0,eps=eps,diff=(1,))
  assert np.all(np.isclose(out1,out2)),'se_1'

  # test se 2d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.se(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'se_00'

  # test se 2d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x1,c1,eps=eps,diff=(1,0))
  add_diffs_to_caches()
  out2 = rbf.basis.se(x1,c1,eps=eps,diff=(1,0))
  assert np.all(np.isclose(out1,out2)),'se_10'

  # test se 2d
  rbf.basis.se.clear_cache()
  out1 = rbf.basis.se(x1,c1,eps=eps,diff=(0,1))
  add_diffs_to_caches()
  out2 = rbf.basis.se(x1,c1,eps=eps,diff=(0,1))
  assert np.all(np.isclose(out1,out2)),'se_10'

  # test mat32 1d
  rbf.basis.mat32.clear_cache()
  out1 = rbf.basis.mat32(x0,c0,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat32(x0,c0,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat32_0'

  # test mat32 2d
  rbf.basis.mat32.clear_cache()
  out1 = rbf.basis.mat32(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat32(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat32_00' 

  # test mat52 1d
  rbf.basis.mat52.clear_cache()
  out1 = rbf.basis.mat52(x0,c0,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat52(x0,c0,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat52_0'

  # test mat52 2d
  rbf.basis.mat52.clear_cache()
  out1 = rbf.basis.mat52(x1,c1,eps=eps)
  add_diffs_to_caches()
  out2 = rbf.basis.mat52(x1,c1,eps=eps)
  assert np.all(np.isclose(out1,out2)),'mat52_00'
