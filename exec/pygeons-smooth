#!/usr/bin/env python
import argparse
import json
import sys
import os
import shutil
import pygeons.ioconv
import pygeons.interface
import logging

def get_extension(f):
  return f.split('.')[-1]

def change_extension(f,ext):
  return '.'.join(f.split('.')[:-1] + [ext])

p = argparse.ArgumentParser(
      description='''Spatially and temporally smooths the data set. 
                     Data is treated as a stochastic variable where 
                     its second time derivative is white noise and its 
                     Laplacian is white noise.''')
p.add_argument('input_file',type=str,
               help='''Date file. Can either be a PBO csv file, a PBO 
                       pos file, or a HDF5 file. The file type is 
                       inferred from the extension. ".hdf", ".h5", 
                       ".hdf5", ".he5" are interpretted as HDF5, 
                       ".pos" is interpretted as PBO pos, anything 
                       else is assumed to be a PBO csv file.''')
p.add_argument('--output_file',type=str,
               help='''If not provided then the input file extension 
                       is removed and replaced with smooth.h5. The 
                       output file type is inferred from the 
                       extension. Currently, can only output to HDF5 
                       files or PBO csv files.''')
p.add_argument('-v','--verbose',action='count',default=0,
               help='''Controls verbosity''')
p.add_argument('-f','--fill',action='store_true',
               help='''Whether to make an estimate at masked data. 
                       Filling masked data can make this function 
                       slower and more likely to encounter a singular 
                       matrix. Defaults to False.''')                      
p.add_argument('--time_scale',type=float,
               help='''Time scale of the smoothed data. Defaults to 
                       10X the time sample period. This is specified 
                       in years''')
p.add_argument('--length_scale',type=float,
               help='''Length scale of the smoothed data. Defaults to 
                       10X the average shortest distance between 
                       stations. This is specified in meters''')
p.add_argument('--cut_dates',nargs='+',type=str,
               help='''list of time discontinuities in YYYY-MM-DD. This date should be 
                       when the discontinuity is first observed''')
p.add_argument('--cut_endpoint1_lons',nargs='+',type=float,
               help='''Coordinates of the spatial discontinuty line 
                       segments. Smoothness is not enforced across 
                       these discontinuities''')
p.add_argument('--cut_endpoint2_lons',nargs='+',type=float,
               help='''Coordinates of the spatial discontinuty line 
                       segments. Smoothness is not enforced across 
                       these discontinuities''')
p.add_argument('--cut_endpoint1_lats',nargs='+',type=float,
               help='''Coordinates of the spatial discontinuty line 
                       segments. Smoothness is not enforced across 
                       these discontinuities''')
p.add_argument('--cut_endpoint2_lats',nargs='+',type=float,
               help='''Coordinates of the spatial discontinuty line 
                       segments. Smoothness is not enforced across 
                       these discontinuities''')
               
p = vars(p.parse_args())

# set logger
verbose = p.pop('verbose')
if verbose == 0:
  logging.basicConfig(level=logging.WARNING)
elif verbose == 1:
  logging.basicConfig(level=logging.INFO)
else:
  logging.basicConfig(level=logging.DEBUG)

input_file = p.pop('input_file')
output_file = p.pop('output_file')

# throw out any Nones and let the lower level functions determine the defaults
for k in p.keys():
  if p[k] is None:
    p.pop(k)

if output_file is None:
  output_file = change_extension(input_file,'smooth.h5')

data_dict = pygeons.ioconv.dict_from_file(input_file)
out_dict = pygeons.interface.smooth(data_dict,**p)
pygeons.ioconv.file_from_dict(output_file,out_dict)

# check to see if there is an associated pert directory
input_pert_dir = input_file+'.pert'
if os.path.exists(input_pert_dir):
  input_ext = get_extension(input_file)
  output_ext = get_extension(output_file)
  output_pert_dir = output_file+'.pert'
  # make output perturbation directory
  if os.path.exists(output_pert_dir):
    shutil.rmtree(output_pert_dir)

  os.mkdir(output_pert_dir)
  input_pert_files = os.listdir(input_pert_dir)
  # output pert files have the same name but with the appropriate 
  # extension
  output_pert_files = [change_extension(i,output_ext) for i in input_pert_files]

  input_pert_paths = [input_pert_dir+'/'+f for f in input_pert_files]
  output_pert_paths = [output_pert_dir+'/'+f for f in output_pert_files]

  for fin,fout in zip(input_pert_paths,output_pert_paths):
    data_dict = pygeons.ioconv.dict_from_file(fin)
    out_dict = pygeons.interface.smooth(data_dict,**p)
    pygeons.ioconv.file_from_dict(fout,out_dict)

